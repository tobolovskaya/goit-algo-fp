# -*- coding: utf-8 -*-
"""ФП_Тоболовська Євгенія.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z9LKkPWeltdJyAtSMabWhApcoa3TTwwv

Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

Реалізація однозв'язного списку
"""

class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def print_list(node):
    while node:
        print(node.value, end=" ")
        node = node.next
    print()

"""Реверсування однозв'язного списку"""

def reverse_list(head):
    prev = None
    current = head
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
    return prev

"""Сортування однозв'язного списку (Сортування злиттям)"""

def merge_sort_list(head):
    if not head or not head.next:
        return head

    # Розділення списку на дві частини
    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    mid = slow.next
    slow.next = None

    # Рекурсивне сортування обох частин
    left = merge_sort_list(head)
    right = merge_sort_list(mid)

    # Злиття двох відсортованих списків
    return merge_sorted_lists(left, right)

def merge_sorted_lists(l1, l2):
    dummy = current = ListNode(0)
    while l1 and l2:
        if l1.value < l2.value:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next

"""Об'єднання двох відсортованих однозв'язних списків"""

# Створення списку для прикладу
head = ListNode(3, ListNode(1, ListNode(2)))

# Реверсування списку
reversed_list = reverse_list(head)
print_list(reversed_list)  # Виведення реверсованого списку

# Сортування списку
sorted_list = merge_sort_list(reversed_list)
print_list(sorted_list)  # Виведення відсортованого списку

# Об'єднання двох відсортованих списків (припустимо, що у нас є ще один відсортований список)
other_sorted_list = ListNode(4, ListNode(5))
merged_list = merge_sorted_lists(sorted_list, other_sorted_list)
print_list(merged_list)  # Виведення об'єднаного відсортованого списку

"""Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії"""

import matplotlib.pyplot as plt
import numpy as np

def draw_tree(x, y, angle, length, depth):
    if depth == 0:
        return
    x_end = x + int(np.cos(np.radians(angle)) * length)
    y_end = y + int(np.sin(np.radians(angle)) * length)

    plt.plot([x, x_end], [y, y_end], 'b-')  # Draw the branch

    # Recursive calls for the two new branches
    new_length = length * 0.8  # Each new branch is 80% the length of the previous one

    draw_tree(x_end, y_end, angle - 45, new_length, depth - 1)  # Left branch
    draw_tree(x_end, y_end, angle + 45, new_length, depth - 1)  # Right branch

# Initial call to draw the tree
plt.figure(figsize=(10, 8))
draw_tree(0, 0, 90, 100, 10)  # Start drawing the tree from the bottom, going up

plt.axis('off')
plt.show()

"""Завдання 3. Дерева, алгоритм Дейкстри"""

import heapq

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[] for _ in range(vertices)]

    def add_edge(self, src, dest, weight):
        self.graph[src].append((dest, weight))

    def dijkstra(self, src):
        dist = [float("inf")] * self.V
        dist[src] = 0
        pq = [(0, src)]  # (distance, vertex)

        while pq:
            (current_dist, current_vertex) = heapq.heappop(pq)

            # Якщо відстань у купі більше ніж поточна відстань, пропускаємо обробку
            if current_dist > dist[current_vertex]:
                continue

            for neighbor, weight in self.graph[current_vertex]:
                distance = current_dist + weight

                if distance < dist[neighbor]:
                    dist[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))

        return dist

# Створення графа
graph = Graph(9)
graph.add_edge(0, 1, 4)
graph.add_edge(0, 7, 8)
graph.add_edge(1, 2, 8)
graph.add_edge(1, 7, 11)
graph.add_edge(2, 3, 7)
graph.add_edge(2, 8, 2)
graph.add_edge(2, 5, 4)
graph.add_edge(3, 4, 9)
graph.add_edge(3, 5, 14)
graph.add_edge(4, 5, 10)
graph.add_edge(5, 6, 2)
graph.add_edge(6, 7, 1)
graph.add_edge(6, 8, 6)
graph.add_edge(7, 8, 7)

# Виклик алгоритму Дейкстри
distances = graph.dijkstra(0)
print("Вершина    Відстань від початку")
for i in range(len(distances)):
    print(f"{i}\t\t{distances[i]}")

"""Завдання 4. Візуалізація піраміди"""

import uuid
import networkx as nx
import matplotlib.pyplot as plt

class Node:
    def __init__(self, key, color="skyblue"):
        self.left = None
        self.right = None
        self.val = key
        self.color = color
        self.id = str(uuid.uuid4())

def add_edges(graph, node, pos, x=0, y=0, layer=1):
    if node is not None:
        graph.add_node(node.id, color=node.color, label=node.val)
        if node.left:
            graph.add_edge(node.id, node.left.id)
            l = x - 1 / 2 ** layer
            pos[node.left.id] = (l, y - 1)
            add_edges(graph, node.left, pos, x=l, y=y - 1, layer=layer + 1)
        if node.right:
            graph.add_edge(node.id, node.right.id)
            r = x + 1 / 2 ** layer
            pos[node.right.id] = (r, y - 1)
            add_edges(graph, node.right, pos, x=r, y=y - 1, layer=layer + 1)
    return graph

def draw_heap(tree_root):
    tree = nx.DiGraph()
    pos = {tree_root.id: (0, 0)}
    tree = add_edges(tree, tree_root, pos)

    colors = [node[1]['color'] for node in tree.nodes(data=True)]
    labels = {node[0]: node[1]['label'] for node in tree.nodes(data=True)}

    plt.figure(figsize=(8, 5))
    nx.draw(tree, pos=pos, labels=labels, arrows=False, node_size=2500, node_color=colors, with_labels=True, font_weight='bold')
    plt.show()

# Приклад використання для створення та візуалізації бінарної купи
root = Node(10)
root.left = Node(8)
root.right = Node(9)
root.left.left = Node(7)
root.left.right = Node(6)
root.right.left = Node(4)

draw_heap(root)

"""Завдання 5. Візуалізація обходу бінарного дерева"""

import matplotlib.pyplot as plt
import networkx as nx
import uuid

class Node:
    def __init__(self, value):
        self.id = str(uuid.uuid4())
        self.value = value
        self.left = None
        self.right = None
        self.color = "#FFFFFF"  # Білий колір за замовчуванням

def add_edges(graph, node, pos, x=0, y=0, layer=1):
    if node is not None:
        graph.add_node(node.id, color=node.color, label=node.value)
        if node.left:
            graph.add_edge(node.id, node.left.id)
            l = x - 1 / 2 ** layer
            pos[node.left.id] = (l, y - 1)
            add_edges(graph, node.left, pos, x=l, y=y - 1, layer=layer + 1)
        if node.right:
            graph.add_edge(node.id, node.right.id)
            r = x + 1 / 2 ** layer
            pos[node.right.id] = (r, y - 1)
            add_edges(graph, node.right, pos, x=r, y=y - 1, layer=layer + 1)
    return graph

def draw_graph_with_colored_nodes(graph, pos):
    colors = [node[1]['color'] for node in graph.nodes(data=True)]
    labels = {node[0]: node[1]['label'] for node in graph.nodes(data=True)}
    nx.draw(graph, pos, labels=labels, with_labels=True, node_color=colors, node_size=2000)

def generate_color(depth, max_depth):
    intensity = 255 - int((depth / max_depth) * 255)
    return f"#{intensity:02X}{intensity:02X}FF"

def dfs_coloring(graph, node, depth=0, max_depth=0):
    if node is not None:
        node.color = generate_color(depth, max_depth)
        dfs_coloring(graph, node.left, depth + 1, max_depth)
        dfs_coloring(graph, node.right, depth + 1, max_depth)

def bfs_coloring(graph, root, max_depth):
    queue = [(root, 0)]
    while queue:
        node, depth = queue.pop(0)
        if node is not None:
            node.color = generate_color(depth, max_depth)
            queue.append((node.left, depth + 1))
            queue.append((node.right, depth + 1))

"""Завдання 6: Жадібні алгоритми та динамічне програмування

Жадібний алгоритм
"""

def greedy_algorithm(items, budget):
    # Створюємо список страв зі співвідношенням калорійності до вартості
    items_ratio = [(name, item["calories"] / item["cost"]) for name, item in items.items()]
    # Сортування страв за співвідношенням калорійності до вартості в спадному порядку
    items_sorted = sorted(items_ratio, key=lambda x: x[1], reverse=True)

    selected_items = []
    total_calories = 0
    for item in items_sorted:
        if items[item[0]]["cost"] <= budget:
            budget -= items[item[0]]["cost"]
            selected_items.append(item[0])
            total_calories += items[item[0]]["calories"]

    return selected_items, total_calories

items = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350}
}

print(greedy_algorithm(items, 100))

"""Алгоритм динамічного програмування"""

def dynamic_programming(items, budget):
    # Створюємо масив для зберігання максимальної калорійності для кожного бюджету
    dp = [0] * (budget + 1)

    for i in range(1, budget + 1):
        for item in items.values():
            if item["cost"] <= i:
                dp[i] = max(dp[i], dp[i - item["cost"]] + item["calories"])

    # Визначаємо які страви були обрані
    selected_items = []
    remaining_budget = budget
    for i in range(budget, 0, -1):
        if dp[i] != dp[i-1]:
            for name, item in items.items():
                if item["cost"] <= remaining_budget and dp[remaining_budget] - dp[remaining_budget - item["cost"]] == item["calories"]:
                    selected_items.append(name)
                    remaining_budget -= item["cost"]
                    break

    return selected_items, dp[budget]

print(dynamic_programming(items, 100))

"""Завдання 7: Використання методу Монте-Карло"""

import numpy as np
import matplotlib.pyplot as plt

# Кількість кидків
n_rolls = 100000

# Симуляція кидків
rolls1 = np.random.randint(1, 7, n_rolls)
rolls2 = np.random.randint(1, 7, n_rolls)
sums = rolls1 + rolls2

# Підрахунок кількості кожної суми
sum_counts = {sum_value: np.sum(sums == sum_value) for sum_value in range(2, 13)}

# Обчислення імовірностей
probabilities = {sum_value: count / n_rolls for sum_value, count in sum_counts.items()}

# Виведення результатів
print("Сума\tЙмовірність")
for sum_value, probability in probabilities.items():
    print(f"{sum_value}\t{probability*100:.2f}%")

# Графік імовірностей
plt.figure(figsize=(10, 6))
plt.bar(probabilities.keys(), probabilities.values(), color='skyblue')
plt.xlabel('Сума чисел на кубиках')
plt.ylabel('Ймовірність (%)')
plt.title('Ймовірності сум при киданні двох кубиків (Метод Монте-Карло)')
plt.xticks(list(range(2, 13)))
plt.show()