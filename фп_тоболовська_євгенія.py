# -*- coding: utf-8 -*-
"""ФП_Тоболовська Євгенія.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z9LKkPWeltdJyAtSMabWhApcoa3TTwwv

Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

Реалізація однозв'язного списку
"""

class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def print_list(node):
    while node:
        print(node.value, end=" ")
        node = node.next
    print()

"""Реверсування однозв'язного списку"""

def reverse_list(head):
    prev = None
    current = head
    while current:
        next_temp = current.next
        current.next = prev
        prev = current
        current = next_temp
    return prev

"""Сортування однозв'язного списку (Сортування злиттям)"""

def merge_sort_list(head):
    if not head or not head.next:
        return head

    # Розділення списку на дві частини
    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    mid = slow.next
    slow.next = None

    # Рекурсивне сортування обох частин
    left = merge_sort_list(head)
    right = merge_sort_list(mid)

    # Злиття двох відсортованих списків
    return merge_sorted_lists(left, right)

def merge_sorted_lists(l1, l2):
    dummy = current = ListNode(0)
    while l1 and l2:
        if l1.value < l2.value:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next

"""Об'єднання двох відсортованих однозв'язних списків"""

# Створення списку для прикладу
head = ListNode(3, ListNode(1, ListNode(2)))

# Реверсування списку
reversed_list = reverse_list(head)
print_list(reversed_list)  # Виведення реверсованого списку

# Сортування списку
sorted_list = merge_sort_list(reversed_list)
print_list(sorted_list)  # Виведення відсортованого списку

# Об'єднання двох відсортованих списків (припустимо, що у нас є ще один відсортований список)
other_sorted_list = ListNode(4, ListNode(5))
merged_list = merge_sorted_lists(sorted_list, other_sorted_list)
print_list(merged_list)  # Виведення об'єднаного відсортованого списку

"""Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії"""

import matplotlib.pyplot as plt
import numpy as np

def draw_tree(x, y, angle, length, depth):
    if depth == 0:
        return
    x_end = x + int(np.cos(np.radians(angle)) * length)
    y_end = y + int(np.sin(np.radians(angle)) * length)

    plt.plot([x, x_end], [y, y_end], 'b-')  # Draw the branch

    # Recursive calls for the two new branches
    new_length = length * 0.8  # Each new branch is 80% the length of the previous one

    draw_tree(x_end, y_end, angle - 45, new_length, depth - 1)  # Left branch
    draw_tree(x_end, y_end, angle + 45, new_length, depth - 1)  # Right branch

# Initial call to draw the tree
plt.figure(figsize=(10, 8))
draw_tree(0, 0, 90, 100, 10)  # Start drawing the tree from the bottom, going up

plt.axis('off')
plt.show()

"""Завдання 3. Дерева, алгоритм Дейкстри"""

import heapq

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[] for _ in range(vertices)]

    def add_edge(self, src, dest, weight):
        self.graph[src].append((dest, weight))

    def dijkstra(self, src):
        dist = [float("inf")] * self.V
        dist[src] = 0
        pq = [(0, src)]  # (distance, vertex)

        while pq:
            (current_dist, current_vertex) = heapq.heappop(pq)

            # Якщо відстань у купі більше ніж поточна відстань, пропускаємо обробку
            if current_dist > dist[current_vertex]:
                continue

            for neighbor, weight in self.graph[current_vertex]:
                distance = current_dist + weight

                if distance < dist[neighbor]:
                    dist[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))

        return dist

# Створення графа
graph = Graph(9)
graph.add_edge(0, 1, 4)
graph.add_edge(0, 7, 8)
graph.add_edge(1, 2, 8)
graph.add_edge(1, 7, 11)
graph.add_edge(2, 3, 7)
graph.add_edge(2, 8, 2)
graph.add_edge(2, 5, 4)
graph.add_edge(3, 4, 9)
graph.add_edge(3, 5, 14)
graph.add_edge(4, 5, 10)
graph.add_edge(5, 6, 2)
graph.add_edge(6, 7, 1)
graph.add_edge(6, 8, 6)
graph.add_edge(7, 8, 7)

# Виклик алгоритму Дейкстри
distances = graph.dijkstra(0)
print("Вершина    Відстань від початку")
for i in range(len(distances)):
    print(f"{i}\t\t{distances[i]}")

"""Завдання 4. Візуалізація піраміди"""

import heapq
import uuid
import networkx as nx
import matplotlib.pyplot as plt

class Node:
    def __init__(self, key, color="skyblue"):
        self.left = None
        self.right = None
        self.val = key
        self.color = color
        self.id = str(uuid.uuid4())

def build_heap_tree(heap_array):
    node_list = [Node(val) for val in heap_array]

    for i in range(len(node_list)):
        left_index = 2 * i + 1
        right_index = 2 * i + 2
        if left_index < len(node_list):
            node_list[i].left = node_list[left_index]
        if right_index < len(node_list):
            node_list[i].right = node_list[right_index]

    return node_list[0] if node_list else None

def draw_heap(tree_root):
    tree = nx.DiGraph()
    pos = {}
    tree = add_edges(tree, tree_root, pos)
    colors = [node[1]['color'] for node in tree.nodes(data=True)]
    labels = {node[0]: node[1]['label'] for node in tree.nodes(data=True)}
    plt.figure(figsize=(8, 5))
    nx.draw(tree, pos=pos, labels=labels, arrows=False, node_size=2500, node_color=colors, with_labels=True, font_weight='bold')
    plt.show()

def add_edges(graph, node, pos, x=0, y=0, layer=1):
    if node is not None:
        graph.add_node(node.id, color=node.color, label=node.val)
        pos[node.id] = (x, y)
        if node.left:
            graph.add_edge(node.id, node.left.id)
            add_edges(graph, node.left, pos, x=x - 1 / 2 ** layer, y=y - 1, layer=layer + 1)
        if node.right:
            graph.add_edge(node.id, node.right.id)
            add_edges(graph, node.right, pos, x=x + 1 / 2 ** layer, y=y - 1, layer=layer + 1)
    return graph

# Приклад використання
heap_array = [1, 3, 5, 7, 9, 2, 4, 34, 2, 1, 2]
heapq.heapify(heap_array)
heap_tree_root = build_heap_tree(heap_array)
draw_heap(heap_tree_root)

"""Завдання 5. Візуалізація обходу бінарного дерева"""

def generate_color(order, total_visits):
    """Генерує колір RGB від темного до світлого залежно від порядку відвідування."""
    ratio = order / total_visits
    # Генеруємо відтінки синього для прикладу
    r = g = 0
    b = 255 - int(ratio * 255)
    return f"#{r:02X}{g:02X}{b:02X}"

current_visit_order = 0  # Лічильник порядку відвідування

def dfs_coloring(node, depth=0, total_visits=1):
    global current_visit_order
    if node:
        node.color = generate_color(current_visit_order, total_visits)
        current_visit_order += 1
        dfs_coloring(node.left, depth + 1, total_visits)
        dfs_coloring(node.right, depth + 1, total_visits)

def bfs_coloring(root, total_visits):
    global current_visit_order
    queue = [(root, 0)]
    while queue:
        node, depth = queue.pop(0)
        if node:
            node.color = generate_color(current_visit_order, total_visits)
            current_visit_order += 1
            queue.append((node.left, depth + 1))
            queue.append((node.right, depth + 1))

"""Завдання 6: Жадібні алгоритми та динамічне програмування

Жадібний алгоритм
"""

def greedy_algorithm(items, budget):
    # Створюємо список страв зі співвідношенням калорійності до вартості
    items_ratio = [(name, item["calories"] / item["cost"]) for name, item in items.items()]
    # Сортування страв за співвідношенням калорійності до вартості в спадному порядку
    items_sorted = sorted(items_ratio, key=lambda x: x[1], reverse=True)

    selected_items = []
    total_calories = 0
    for item in items_sorted:
        if items[item[0]]["cost"] <= budget:
            budget -= items[item[0]]["cost"]
            selected_items.append(item[0])
            total_calories += items[item[0]]["calories"]

    return selected_items, total_calories

items = {
    "pizza": {"cost": 50, "calories": 300},
    "hamburger": {"cost": 40, "calories": 250},
    "hot-dog": {"cost": 30, "calories": 200},
    "pepsi": {"cost": 10, "calories": 100},
    "cola": {"cost": 15, "calories": 220},
    "potato": {"cost": 25, "calories": 350}
}

print(greedy_algorithm(items, 100))

"""Алгоритм динамічного програмування"""

def dynamic_programming(items, budget):
    # Кількість страв
    n = len(items)

    # Створюємо таблицю для збереження максимальної калорійності для кожної вартості до budget
    dp = [[0 for x in range(budget + 1)] for x in range(n + 1)]

    # Побудова таблиці dp в напрямку знизу вгору
    for i in range(1, n + 1):
        for w in range(1, budget + 1):
            # Вартість і калорійність поточної страви
            cost = items[i-1]['cost']
            calories = items[i-1]['calories']

            if cost <= w:
                # Вибираємо максимум між не включенням цієї страви та включенням її з урахуванням калорійності
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-cost] + calories)
            else:
                # Якщо страву не можна включити, то калорійність не змінюється
                dp[i][w] = dp[i-1][w]

    # Результат знаходиться в dp[n][budget]
    return dp[n][budget]

# Приклад використання
items = [
    {"cost": 50, "calories": 300},
    {"cost": 40, "calories": 250},
    {"cost": 30, "calories": 200},
    {"cost": 10, "calories": 100},
    {"cost": 15, "calories": 220},
    {"cost": 25, "calories": 350}
]
budget = 100  # Максимальна сума грошей, яку можна витратити

max_calories = dynamic_programming(items, budget)
print(f"Максимальна калорійність, яку можна отримати з бюджетом {budget}: {max_calories}")

"""Завдання 7: Використання методу Монте-Карло"""

import numpy as np
import matplotlib.pyplot as plt

# Кількість кидків
n_rolls = 100000

# Симуляція кидків
rolls1 = np.random.randint(1, 7, n_rolls)
rolls2 = np.random.randint(1, 7, n_rolls)
sums = rolls1 + rolls2

# Підрахунок кількості кожної суми
sum_counts = {sum_value: np.sum(sums == sum_value) for sum_value in range(2, 13)}

# Обчислення імовірностей
probabilities = {sum_value: count / n_rolls for sum_value, count in sum_counts.items()}

# Виведення результатів
print("Сума\tЙмовірність")
for sum_value, probability in probabilities.items():
    print(f"{sum_value}\t{probability*100:.2f}%")

# Графік імовірностей
plt.figure(figsize=(10, 6))
plt.bar(probabilities.keys(), probabilities.values(), color='skyblue')
plt.xlabel('Сума чисел на кубиках')
plt.ylabel('Ймовірність (%)')
plt.title('Ймовірності сум при киданні двох кубиків (Метод Монте-Карло)')
plt.xticks(list(range(2, 13)))
plt.show()